<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Datamosh Studio</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=VT323&display=swap" rel="stylesheet">
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        :root {
            --neon-green: #00ff41;
            --neon-red: #ff0055;
            --neon-blue: #00ffff;
            --dark-bg: #050505;
            --panel-bg: #111111;
        }

        body {
            background-color: var(--dark-bg);
            color: var(--neon-green);
            font-family: 'Share Tech Mono', monospace;
            overflow-x: hidden;
            -webkit-tap-highlight-color: transparent;
        }

        /* Glitch Text Effect */
        .glitch-text {
            position: relative;
            animation: glitch-skew 1s infinite linear alternate-reverse;
        }
        .glitch-text::before, .glitch-text::after {
            content: attr(data-text);
            position: absolute;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .glitch-text::before {
            left: 2px;
            text-shadow: -1px 0 var(--neon-red);
            clip: rect(44px, 450px, 56px, 0);
            animation: glitch-anim 5s infinite linear alternate-reverse;
        }
        .glitch-text::after {
            left: -2px;
            text-shadow: -1px 0 var(--neon-blue);
            clip: rect(44px, 450px, 56px, 0);
            animation: glitch-anim2 5s infinite linear alternate-reverse;
        }

        @keyframes glitch-anim {
            0% { clip: rect(12px, 9999px, 5px, 0); }
            5% { clip: rect(34px, 9999px, 1px, 0); }
            100% { clip: rect(1px, 9999px, 89px, 0); }
        }
        @keyframes glitch-anim2 {
            0% { clip: rect(82px, 9999px, 25px, 0); }
            5% { clip: rect(14px, 9999px, 61px, 0); }
            100% { clip: rect(51px, 9999px, 19px, 0); }
        }

        /* Custom Range Slider */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
            margin: 6px 0;
        }
        input[type=range]:focus { outline: none; }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            background: #333;
            border: 1px solid var(--neon-green);
            box-shadow: 0 0 2px var(--neon-green);
        }
        input[type=range]::-webkit-slider-thumb {
            height: 16px;
            width: 8px;
            background: var(--neon-green);
            cursor: pointer;
            -webkit-appearance: none;
            margin-top: -7px;
            box-shadow: 0 0 8px var(--neon-green);
            transition: transform 0.1s;
        }
        
        /* RGB Specific Sliders */
        .slider-r::-webkit-slider-runnable-track { border-color: #ff0055; box-shadow: 0 0 2px #ff0055; }
        .slider-r::-webkit-slider-thumb { background: #ff0055; box-shadow: 0 0 8px #ff0055; }
        
        .slider-g::-webkit-slider-runnable-track { border-color: #00ff41; box-shadow: 0 0 2px #00ff41; }
        .slider-g::-webkit-slider-thumb { background: #00ff41; box-shadow: 0 0 8px #00ff41; }
        
        .slider-b::-webkit-slider-runnable-track { border-color: #00ffff; box-shadow: 0 0 2px #00ffff; }
        .slider-b::-webkit-slider-thumb { background: #00ffff; box-shadow: 0 0 8px #00ffff; }

        /* Scrollbar for Layer List */
        .layer-scroll::-webkit-scrollbar { width: 4px; height: 4px; }
        .layer-scroll::-webkit-scrollbar-thumb { background: #333; }
        
        .scanlines {
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.2) 50%,
                rgba(0,0,0,0.2)
            );
            background-size: 100% 4px;
            pointer-events: none;
        }

        canvas { image-rendering: pixelated; }

        .active-layer {
            background-color: rgba(0, 255, 65, 0.1);
            border-color: var(--neon-green);
        }

        /* Toggle Switch */
        .toggle-checkbox:checked {
            right: 0;
            border-color: #68D391;
        }
        .toggle-checkbox:checked + .toggle-label {
            background-color: #68D391;
        }
    </style>
</head>
<body class="h-screen flex flex-col">

    <!-- Header -->
    <header class="p-4 border-b border-green-900 bg-black flex justify-between items-center z-20 shrink-0">
        <div class="flex items-center gap-2">
            <i data-lucide="layers" class="text-green-500 w-6 h-6"></i>
            <h1 class="text-2xl font-bold tracking-tighter glitch-text" data-text="DATAMOSH">DATAMOSH</h1>
        </div>
        <div class="flex gap-2">
            <button id="helpBtn" class="p-2 border border-green-900 hover:bg-green-900/30 rounded text-xs transition-colors">GUIDE</button>
        </div>
    </header>

    <!-- Guide Overlay -->
    <div id="guideOverlay" class="hidden fixed inset-0 z-50 bg-black/95 flex items-center justify-center p-4 cursor-pointer" onclick="this.classList.add('hidden')">
        <div class="max-w-md w-full border border-green-900 bg-gray-900/80 p-6 rounded-lg backdrop-blur-md shadow-[0_0_50px_rgba(0,255,65,0.1)]" onclick="event.stopPropagation()">
            <h2 class="text-2xl font-bold text-white mb-6 tracking-tighter border-b border-green-900 pb-2">OPERATOR MANUAL</h2>
            
            <div class="space-y-6 text-sm text-gray-300 font-mono leading-relaxed">
                <p class="flex flex-wrap items-center gap-2">
                    <span class="text-green-500 font-bold">1. LAYERS:</span> Select an effect and click 
                    <span class="inline-flex items-center justify-center w-6 h-6 border border-green-700 bg-green-900/30 text-green-400 font-bold rounded-sm text-xs">+</span> 
                    to add it to your stack. Reorder effects using the <span class="text-gray-500 font-bold text-xs">&lt; &gt;</span> arrows.
                </p>
                
                <p class="flex flex-wrap items-center gap-2">
                    <span class="text-green-500 font-bold">2. SOURCES:</span> Upload videos to 
                    <span class="inline-block px-1.5 py-0.5 border border-solid border-green-700 bg-green-900/20 text-green-400 font-bold text-[10px] rounded-sm">SRC A</span> 
                    and 
                    <span class="inline-block px-1.5 py-0.5 border border-dashed border-green-700 text-gray-400 text-[10px] rounded-sm">SRC B</span>.
                    Effects like "Motion Transfer" blend them together.
                </p>
                
                <p class="flex flex-wrap items-center gap-2">
                    <span class="text-green-500 font-bold">3. TWEAK:</span> Click any layer to reveal its 
                    <span class="inline-block px-1.5 py-0.5 bg-green-900/20 text-green-400 font-bold text-[10px] rounded-sm border border-green-900/30">CONTROLS</span> 
                    below. Adjust sliders to destroy the footage.
                </p>
            </div>

            <button class="mt-8 w-full py-3 bg-green-600 hover:bg-green-500 text-black font-bold rounded-sm transition-colors shadow-[4px_4px_0px_rgba(0,0,0,0.5)] active:translate-y-1 active:shadow-none" onclick="document.getElementById('guideOverlay').classList.add('hidden')">
                INITIALIZE
            </button>
        </div>
    </div>

    <!-- Main Workspace -->
    <main class="flex-1 flex flex-col relative overflow-hidden">
        
        <!-- Canvas Container -->
        <div class="flex-1 relative flex items-center justify-center bg-gray-900 overflow-hidden">
            <!-- Hidden Video Sources -->
            <video id="sourceA" class="hidden" loop muted playsinline crossorigin="anonymous"></video>
            <video id="sourceB" class="hidden" loop muted playsinline crossorigin="anonymous"></video>
            
            <!-- Output Canvas -->
            <canvas id="moshCanvas" class="w-full max-w-4xl h-auto aspect-video border-2 border-green-900/50 shadow-[0_0_20px_rgba(0,255,65,0.1)] bg-black"></canvas>
            
            <div class="absolute inset-0 scanlines pointer-events-none opacity-30"></div>

            <!-- Loading/Start State -->
            <div id="placeholderState" class="absolute inset-0 flex flex-col items-center justify-center bg-black/80 z-10 backdrop-blur-sm p-6 text-center">
                <i data-lucide="upload-cloud" class="w-16 h-16 text-green-500 mb-4 animate-pulse"></i>
                <h2 class="text-xl mb-2">Initialize Sequence</h2>
                <p class="text-gray-400 text-sm max-w-md mb-6">Upload primary video. Stack layers to compound effects.</p>
                <label class="cursor-pointer bg-green-600 hover:bg-green-500 text-black font-bold py-3 px-8 rounded-none border border-green-400 shadow-[4px_4px_0px_#003300] active:translate-y-1 active:shadow-none transition-all">
                    UPLOAD SOURCE A
                    <input type="file" id="uploadA" accept="video/*" class="hidden">
                </label>
            </div>
        </div>

        <!-- Controls Panel -->
        <div class="bg-black/95 border-t border-green-900 p-3 z-20 max-h-[55vh] flex flex-col backdrop-blur-md">
            
            <!-- Top Row: Transport & Add Layer -->
            <div class="flex items-center gap-2 mb-3 shrink-0">
                <button id="playBtn" class="p-3 bg-gray-800 border border-green-700 rounded-full hover:bg-green-900 transition-colors shrink-0" disabled>
                    <i data-lucide="play" class="w-5 h-5 fill-current"></i>
                </button>

                <!-- Combined Add Layer Group -->
                <div class="flex-1 flex items-stretch">
                    <select id="newLayerSelect" class="flex-1 bg-black text-green-500 border border-green-700 border-r-0 p-2 text-xs font-mono uppercase focus:outline-none focus:border-green-400 rounded-l-sm rounded-r-none">
                        <option value="smear">SMEAR (I-FRAME)</option>
                        <option value="quantize">QUANTIZE (ALIASING)</option>
                        <option value="drift">VECTOR DRIFT</option>
                        <option value="freeze">FREEZE ZONE</option>
                        <option value="echo">VECTOR ECHO</option>
                        <option value="transfer">MOTION TRANSFER</option>
                        <option value="luma_wipe">LUMA WIPE</option>
                        <option value="interlace">INTERLACE</option>
                        <option value="rgb">RGB OFFSET</option>
                        <option value="sort">PIXEL SORT</option>
                        <option value="slice">ROW SLICER</option>
                        <option value="difference">DIFF GLITCH</option>
                        <option value="noise">NOISE/GRAIN</option>
                    </select>
                    <button id="addLayerBtn" class="px-3 border border-green-700 hover:bg-green-900/50 text-green-400 font-bold rounded-r-sm rounded-l-none border-l-0 bg-green-900/10">+</button>
                </div>

                <!-- Sources Group -->
                <div class="flex gap-2">
                    <label id="aLabel" class="cursor-pointer p-2 border border-solid border-green-700 hover:bg-green-900/30 rounded text-center w-[60px] shrink-0 transition-all bg-green-900/20" title="Swap Source A">
                        <span class="text-[9px] block text-green-400 font-bold">SRC A</span>
                        <i data-lucide="refresh-cw" class="w-3 h-3 mx-auto text-green-500 mt-0.5"></i>
                        <input type="file" id="changeSourceA" accept="video/*" class="hidden">
                    </label>

                    <label id="bLabel" class="cursor-pointer p-2 border border-dashed border-green-700 hover:bg-green-900/30 rounded text-center w-[60px] shrink-0 transition-all" title="Upload/Swap Source B">
                        <span class="text-[9px] block text-gray-400">SRC B</span>
                        <i id="bIcon" data-lucide="plus" class="w-3 h-3 mx-auto mt-0.5"></i>
                        <input type="file" id="uploadB" accept="video/*" class="hidden">
                    </label>
                </div>
            </div>

            <!-- Layer List (Horizontal Scroll) -->
            <div id="layerList" class="flex gap-2 overflow-x-auto layer-scroll pb-2 mb-3 min-h-[50px]">
                <!-- Layers injected here -->
            </div>

            <!-- Parameters Area -->
            <div class="border-t border-green-900/50 pt-3 flex-1 overflow-y-auto">
                <div class="flex justify-between items-center mb-2">
                    <span id="activeLayerName" class="text-xs font-bold text-green-400 bg-green-900/20 px-2 py-0.5 rounded">LAYER CONTROLS</span>
                    <button id="removeLayerBtn" class="text-[10px] text-red-500 hover:text-red-400 border border-red-900 px-2 rounded">REMOVE LAYER</button>
                </div>
                
                <!-- Direction Control (Conditional) -->
                <div id="dirControl" class="hidden flex items-center justify-between bg-gray-900 border border-green-900/50 p-2 rounded mb-3">
                    <span class="text-xs font-bold text-green-400">DIRECTION</span>
                    <div class="flex items-center gap-2 cursor-pointer" id="dirWrapper">
                        <span id="dirLabelA" class="text-[10px] text-green-500 font-bold font-mono">A &rarr; B</span>
                        <div class="w-8 h-4 bg-gray-800 border border-green-700 rounded-full relative transition-colors">
                            <div id="dirKnob" class="w-2 h-2 bg-green-500 rounded-full absolute top-1 left-1 transition-all"></div>
                        </div>
                        <span id="dirLabelB" class="text-[10px] text-gray-600 font-mono">B &rarr; A</span>
                    </div>
                </div>

                <!-- STANDARD CONTROLS -->
                <div id="standardControls" class="grid grid-cols-1 md:grid-cols-3 gap-x-6 gap-y-3">
                    <div>
                        <div class="flex justify-between text-xs mb-1">
                            <span id="label1" class="uppercase text-green-400 font-bold truncate pr-2">Param 1</span>
                            <span id="val1" class="text-gray-400 font-mono">0</span>
                        </div>
                        <input type="range" id="param1" min="0" max="100">
                    </div>
                    <div>
                        <div class="flex justify-between text-xs mb-1">
                            <span id="label2" class="uppercase text-green-400 font-bold truncate pr-2">Param 2</span>
                            <span id="val2" class="text-gray-400 font-mono">0</span>
                        </div>
                        <input type="range" id="param2" min="0" max="100">
                    </div>
                    <div>
                        <div class="flex justify-between text-xs mb-1">
                            <span id="label3" class="uppercase text-green-400 font-bold truncate pr-2">Param 3</span>
                            <span id="val3" class="text-gray-400 font-mono">0</span>
                        </div>
                        <input type="range" id="param3" min="0" max="100">
                    </div>
                </div>

                <!-- RGB CONTROLS -->
                <div id="rgbControls" class="hidden">
                    <div class="flex flex-col md:flex-row gap-4">
                        <div class="flex items-center justify-center shrink-0">
                            <div class="bg-black border border-gray-800 p-1 relative">
                                <canvas id="rgbVisualizer" width="80" height="80" class="border border-gray-800"></canvas>
                            </div>
                        </div>
                        <div class="grid grid-cols-2 gap-x-4 gap-y-1 flex-1">
                            <div>
                                <div class="flex justify-between text-[10px] text-[#ff0055]"><span>R-X</span><span id="vRX">0</span></div>
                                <input type="range" id="rx" min="-50" max="50" class="slider-r">
                            </div>
                            <div>
                                <div class="flex justify-between text-[10px] text-[#ff0055]"><span>R-Y</span><span id="vRY">0</span></div>
                                <input type="range" id="ry" min="-50" max="50" class="slider-r">
                            </div>
                            <div>
                                <div class="flex justify-between text-[10px] text-[#00ff41]"><span>G-X</span><span id="vGX">0</span></div>
                                <input type="range" id="gx" min="-50" max="50" class="slider-g">
                            </div>
                            <div>
                                <div class="flex justify-between text-[10px] text-[#00ff41]"><span>G-Y</span><span id="vGY">0</span></div>
                                <input type="range" id="gy" min="-50" max="50" class="slider-g">
                            </div>
                            <div>
                                <div class="flex justify-between text-[10px] text-[#00ffff]"><span>B-X</span><span id="vBX">0</span></div>
                                <input type="range" id="bx" min="-50" max="50" class="slider-b">
                            </div>
                            <div>
                                <div class="flex justify-between text-[10px] text-[#00ffff]"><span>B-Y</span><span id="vBY">0</span></div>
                                <input type="range" id="by" min="-50" max="50" class="slider-b">
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Footer: Record -->
            <div class="flex gap-3 mt-3 shrink-0">
                <button id="recordBtn" class="flex-1 py-3 bg-red-900/20 border border-red-800 text-red-500 hover:bg-red-900/40 uppercase font-bold tracking-wider rounded-sm flex items-center justify-center gap-2 transition-all" disabled>
                    <div id="recDot" class="w-3 h-3 rounded-full bg-red-600"></div>
                    <span id="recText">REC OUTPUT</span>
                </button>
                <button id="snapBtn" class="px-4 border border-green-700 hover:bg-green-900/30 text-green-500 rounded-sm transition-colors" disabled>
                    <i data-lucide="camera" class="w-5 h-5"></i>
                </button>
            </div>
        </div>
    </main>

    <!-- Scripts -->
    <script>
        lucide.createIcons();

        // --- Core Elements ---
        const videoA = document.getElementById('sourceA');
        const videoB = document.getElementById('sourceB');
        const canvas = document.getElementById('moshCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        
        // --- UI Elements ---
        const standardControls = document.getElementById('standardControls');
        const rgbControls = document.getElementById('rgbControls');
        const dirControl = document.getElementById('dirControl');
        const dirWrapper = document.getElementById('dirWrapper');
        const dirKnob = document.getElementById('dirKnob');
        const dirLabelA = document.getElementById('dirLabelA');
        const dirLabelB = document.getElementById('dirLabelB');
        
        const layerList = document.getElementById('layerList');
        const activeLayerName = document.getElementById('activeLayerName');
        const visCanvas = document.getElementById('rgbVisualizer');
        const visCtx = visCanvas.getContext('2d');

        const playBtn = document.getElementById('playBtn');
        const addLayerBtn = document.getElementById('addLayerBtn');
        const removeLayerBtn = document.getElementById('removeLayerBtn');
        const newLayerSelect = document.getElementById('newLayerSelect');
        const placeholderState = document.getElementById('placeholderState');
        const recordBtn = document.getElementById('recordBtn');
        const snapBtn = document.getElementById('snapBtn');
        const helpBtn = document.getElementById('helpBtn');
        const guideOverlay = document.getElementById('guideOverlay');

        // Sliders
        const param1 = document.getElementById('param1');
        const param2 = document.getElementById('param2');
        const param3 = document.getElementById('param3');
        const label1 = document.getElementById('label1');
        const label2 = document.getElementById('label2');
        const label3 = document.getElementById('label3');
        const val1 = document.getElementById('val1');
        const val2 = document.getElementById('val2');
        const val3 = document.getElementById('val3');

        const rgbInputs = {
            rx: document.getElementById('rx'), ry: document.getElementById('ry'),
            gx: document.getElementById('gx'), gy: document.getElementById('gy'),
            bx: document.getElementById('bx'), by: document.getElementById('by')
        };
        const rgbLabels = {
            rx: document.getElementById('vRX'), ry: document.getElementById('vRY'),
            gx: document.getElementById('vGX'), gy: document.getElementById('vGY'),
            bx: document.getElementById('vBX'), by: document.getElementById('vBY')
        };

        // --- Config ---
        // def array is now [p1, p2, p3, dir(0=A->B, 1=B->A)]
        const modeConfig = {
            'smear': { name: 'Smear', l1: 'Thresh', l2: 'Decay', l3: 'Mosaic', def: [15, 0, 0, 0], hasDir: false },
            'quantize': { name: 'Quantize', l1: 'Block Size', l2: 'Thresh', l3: 'Crush', def: [20, 15, 0, 0], hasDir: false },
            'drift': { name: 'Drift', l1: 'Speed X', l2: 'Speed Y', l3: 'Noise', def: [55, 50, 0, 0], hasDir: false },
            'freeze': { name: 'Freeze', l1: 'Radius', l2: 'Feather', l3: 'Invert', def: [30, 10, 0, 0], hasDir: false },
            'echo': { name: 'Echo', l1: 'Decay', l2: 'Offset', l3: 'Thresh', def: [80, 0, 10, 0], hasDir: false },
            'transfer': { name: 'Motion', l1: 'Sens', l2: 'Blend', l3: 'Luma Mask', def: [20, 100, 0, 0], hasDir: true },
            'luma_wipe': { name: 'Luma Wipe', l1: 'Thresh', l2: 'Softness', l3: 'Unused', def: [50, 10, 0, 0], hasDir: true },
            'interlace': { name: 'Interlace', l1: 'Height', l2: 'Scan', l3: 'Jitter', def: [4, 0, 0, 0], hasDir: true },
            'difference': { name: 'Diff Glitch', l1: 'Thresh', l2: 'Ghost', l3: 'Color', def: [25, 80, 0, 0], hasDir: false },
            'sort': { name: 'Sort', l1: 'Drift', l2: 'Thresh', l3: 'Dir', def: [10, 50, 0, 0], hasDir: false },
            'slice': { name: 'Slicer', l1: 'Chance', l2: 'Height', l3: 'Shift', def: [10, 20, 10, 0], hasDir: false },
            'rgb': { name: 'RGB Offset', type: 'rgb', def: {rx:0, ry:0, gx:0, gy:0, bx:0, by:0}, hasDir: false },
            'noise': { name: 'Noise', l1: 'Grain', l2: 'Interf', l3: 'V-Sync', def: [20, 5, 0, 0], hasDir: false }
        };

        // --- State ---
        let layers = []; // Array of { id, type, params }
        let selectedLayerId = null;
        let isPlaying = false;
        let animationId;
        let processingWidth = 640; 
        let processingHeight = 360;
        let previousFrameData = null; 
        let mediaRecorder;
        let recordedChunks = [];
        let isRecording = false;

        // --- Layer Management ---
        function addLayer(type) {
            const config = modeConfig[type];
            const newId = Date.now() + Math.random().toString(36).substr(2, 9);
            const params = config.type === 'rgb' ? {...config.def} : [...config.def];
            
            const layer = { id: newId, type: type, params: params };
            layers.push(layer);
            selectLayer(newId);
            renderLayers();
        }

        function removeLayer(id) {
            layers = layers.filter(l => l.id !== id);
            if (selectedLayerId === id) {
                selectedLayerId = layers.length > 0 ? layers[layers.length-1].id : null;
            }
            renderLayers();
            updateControls();
        }

        function selectLayer(id) {
            selectedLayerId = id;
            renderLayers();
            updateControls();
        }

        function moveLayer(e, index, direction) {
            e.stopPropagation();
            const newIndex = index + direction;
            if (newIndex < 0 || newIndex >= layers.length) return;
            [layers[index], layers[newIndex]] = [layers[newIndex], layers[index]];
            renderLayers();
        }

        function renderLayers() {
            layerList.innerHTML = '';
            layers.forEach((layer, index) => {
                const config = modeConfig[layer.type];
                const div = document.createElement('div');
                div.className = `min-w-[120px] p-2 border border-green-900 bg-gray-900 rounded cursor-pointer flex flex-col justify-between transition-all ${layer.id === selectedLayerId ? 'active-layer' : 'opacity-70 hover:opacity-100'}`;
                
                const canMoveLeft = index > 0;
                const canMoveRight = index < layers.length - 1;
                const leftClass = canMoveLeft ? "hover:text-white cursor-pointer" : "opacity-30 cursor-default";
                const rightClass = canMoveRight ? "hover:text-white cursor-pointer" : "opacity-30 cursor-default";

                div.innerHTML = `
                    <div class="flex justify-between items-center mb-1">
                        <div class="text-[10px] text-gray-400 font-mono">#${index+1}</div>
                        <div class="flex gap-1 text-[10px] text-gray-500 font-bold">
                            <span class="${leftClass}" data-dir="-1">&lt;</span>
                            <span class="${rightClass}" data-dir="1">&gt;</span>
                        </div>
                    </div>
                    <div class="text-xs font-bold text-green-500 truncate">${config.name}</div>
                `;
                
                div.onclick = () => selectLayer(layer.id);
                div.querySelectorAll('span[data-dir]').forEach(span => {
                    span.onclick = (e) => {
                        const dir = parseInt(span.getAttribute('data-dir'));
                        if ((dir === -1 && index > 0) || (dir === 1 && index < layers.length - 1)) {
                            moveLayer(e, index, dir);
                        } else {
                            e.stopPropagation();
                        }
                    };
                });
                layerList.appendChild(div);
            });
        }

        function updateControls() {
            const layer = layers.find(l => l.id === selectedLayerId);
            if (!layer) {
                activeLayerName.textContent = "NO LAYER SELECTED";
                standardControls.classList.add('hidden');
                rgbControls.classList.add('hidden');
                dirControl.classList.add('hidden');
                removeLayerBtn.disabled = true;
                return;
            }
            
            removeLayerBtn.disabled = false;
            const config = modeConfig[layer.type];
            activeLayerName.textContent = `${config.name.toUpperCase()} CONTROLS`;

            // Direction Control Logic
            if (config.hasDir) {
                dirControl.classList.remove('hidden');
                const isRev = layer.params[3] === 1;
                if (isRev) {
                    dirKnob.style.left = 'auto'; dirKnob.style.right = '4px';
                    dirLabelB.classList.add('text-green-500', 'font-bold'); dirLabelB.classList.remove('text-gray-600');
                    dirLabelA.classList.remove('text-green-500', 'font-bold'); dirLabelA.classList.add('text-gray-600');
                } else {
                    dirKnob.style.left = '4px'; dirKnob.style.right = 'auto';
                    dirLabelA.classList.add('text-green-500', 'font-bold'); dirLabelA.classList.remove('text-gray-600');
                    dirLabelB.classList.remove('text-green-500', 'font-bold'); dirLabelB.classList.add('text-gray-600');
                }
            } else {
                dirControl.classList.add('hidden');
            }

            if (config.type === 'rgb') {
                standardControls.classList.add('hidden');
                rgbControls.classList.remove('hidden');
                Object.keys(rgbInputs).forEach(k => {
                    rgbInputs[k].value = layer.params[k];
                    rgbLabels[k].textContent = layer.params[k];
                });
                updateVisualizer(layer.params);
            } else {
                standardControls.classList.remove('hidden');
                rgbControls.classList.add('hidden');

                label1.textContent = config.l1;
                label2.textContent = config.l2;
                label3.textContent = config.l3;

                param1.value = layer.params[0];
                param2.value = layer.params[1];
                param3.value = layer.params[2];

                val1.textContent = layer.params[0];
                val2.textContent = layer.params[1];
                val3.textContent = layer.params[2];
            }
        }

        // --- Event Listeners (UI) ---
        addLayerBtn.onclick = () => addLayer(newLayerSelect.value);
        removeLayerBtn.onclick = () => { if(selectedLayerId) removeLayer(selectedLayerId); };
        helpBtn.onclick = () => guideOverlay.classList.remove('hidden');

        dirWrapper.onclick = () => {
            const layer = layers.find(l => l.id === selectedLayerId);
            if (layer && modeConfig[layer.type].hasDir) {
                layer.params[3] = layer.params[3] === 0 ? 1 : 0;
                updateControls();
            }
        };

        [param1, param2, param3].forEach((p, idx) => {
            p.oninput = (e) => {
                const layer = layers.find(l => l.id === selectedLayerId);
                if (layer && layer.type !== 'rgb') {
                    layer.params[idx] = parseInt(e.target.value);
                    [val1, val2, val3][idx].textContent = e.target.value;
                }
            };
        });

        Object.keys(rgbInputs).forEach(k => {
            rgbInputs[k].oninput = (e) => {
                const layer = layers.find(l => l.id === selectedLayerId);
                if (layer && layer.type === 'rgb') {
                    layer.params[k] = parseInt(e.target.value);
                    rgbLabels[k].textContent = e.target.value;
                    updateVisualizer(layer.params);
                }
            };
        });

        function updateVisualizer(p) {
            const w = visCanvas.width;
            const h = visCanvas.height;
            const cx = w/2, cy = h/2;
            visCtx.fillStyle = '#000'; visCtx.fillRect(0,0,w,h);
            visCtx.strokeStyle = '#222'; visCtx.beginPath();
            visCtx.moveTo(cx,0); visCtx.lineTo(cx,h); visCtx.moveTo(0,cy); visCtx.lineTo(w,cy); visCtx.stroke();
            visCtx.globalCompositeOperation = 'screen';
            const dot = (x,y,c) => {
                visCtx.fillStyle = c; visCtx.beginPath();
                visCtx.arc(cx + (x*0.6), cy + (y*0.6), 4, 0, Math.PI*2); visCtx.fill();
            };
            dot(p.rx, p.ry, '#ff0055');
            dot(p.gx, p.gy, '#00ff41');
            dot(p.bx, p.by, '#00ffff');
            visCtx.globalCompositeOperation = 'source-over';
        }

        // --- Core Engine & Pipeline ---
        function initCanvas() {
            canvas.width = processingWidth;
            canvas.height = processingHeight;
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            addLayer('smear');
        }

        document.getElementById('uploadA').onchange = (e) => handleUpload(e.target.files[0], videoA, true);
        document.getElementById('changeSourceA').onchange = (e) => handleUpload(e.target.files[0], videoA, true);
        document.getElementById('uploadB').onchange = (e) => handleUpload(e.target.files[0], videoB, false);

        function handleUpload(file, vid, isPrimary) {
            if(!file) return;
            vid.src = URL.createObjectURL(file);
            vid.load();
            vid.onloadeddata = () => {
                if(isPrimary) {
                    const aspect = vid.videoWidth / vid.videoHeight;
                    processingHeight = Math.floor(processingWidth / aspect);
                    canvas.width = processingWidth;
                    canvas.height = processingHeight;
                    placeholderState.classList.add('hidden');
                    playBtn.disabled = false;
                    recordBtn.disabled = false;
                    snapBtn.disabled = false;
                    isPlaying = true;
                    videoA.play();
                    if(videoB.readyState>=2) videoB.play();
                    startLoop();
                } else {
                    document.getElementById('bLabel').classList.remove('border-dashed');
                    document.getElementById('bLabel').classList.add('bg-green-600', 'text-black', 'border-solid');
                    document.getElementById('bIcon').setAttribute('data-lucide', 'check');
                    lucide.createIcons();
                    if(isPlaying) vid.play();
                }
            };
        }

        playBtn.onclick = () => {
            if(isPlaying) {
                videoA.pause();
                if(videoB.src) videoB.pause();
                playBtn.innerHTML = '<i data-lucide="play" class="w-5 h-5 fill-current"></i>';
                cancelAnimationFrame(animationId);
                isPlaying = false;
            } else {
                videoA.play();
                if(videoB.src) videoB.play();
                playBtn.innerHTML = '<i data-lucide="pause" class="w-5 h-5 fill-current"></i>';
                isPlaying = true;
                loop();
            }
            lucide.createIcons();
        };

        function loop() {
            if(!isPlaying) return;
            processPipeline();
            animationId = requestAnimationFrame(loop);
        }
        function startLoop() { if(animationId) cancelAnimationFrame(animationId); loop(); }

        // *** THE PIPELINE ***
        function processPipeline() {
            if (videoA.readyState < 2) return;
            const w = canvas.width;
            const h = canvas.height;

            // 1. Get Inputs
            const tempC = document.createElement('canvas');
            tempC.width = w; tempC.height = h;
            const tempCtx = tempC.getContext('2d');
            
            tempCtx.drawImage(videoA, 0, 0, w, h);
            const frameA = tempCtx.getImageData(0, 0, w, h);
            
            let frameB = null;
            if (videoB.readyState >= 2 && !videoB.paused) {
                tempCtx.drawImage(videoB, 0, 0, w, h);
                frameB = tempCtx.getImageData(0, 0, w, h);
            } else if (videoB.readyState >= 2 && isPlaying) {
                videoB.play();
                tempCtx.drawImage(videoB, 0, 0, w, h);
                frameB = tempCtx.getImageData(0, 0, w, h);
            }

            // 2. Prepare History
            if (!previousFrameData) {
                ctx.putImageData(frameA, 0, 0);
                previousFrameData = ctx.getImageData(0,0,w,h);
                return;
            }

            let currentCanvas = ctx.getImageData(0,0,w,h);
            let buffer = new Uint8ClampedArray(currentCanvas.data); 
            
            layers.forEach(layer => {
                const outputData = new Uint8ClampedArray(buffer); 
                const p = layer.params;
                
                const dA = frameA.data;
                const dP = previousFrameData.data;
                const dC = buffer; 
                const dOut = outputData;

                if (layer.type === 'smear') {
                    const thresh = p[0] * 1.5;
                    const crush = p[1];
                    const blockSize = Math.max(1, Math.floor(p[2]/3));

                    for (let y=0; y<h; y++) {
                        for (let x=0; x<w; x++) {
                            const i = (y*w+x)*4;
                            let rx = blockSize>1 ? x-(x%blockSize) : x;
                            let ry = blockSize>1 ? y-(y%blockSize) : y;
                            let ri = (ry*w+rx)*4;

                            const diff = Math.abs(dA[ri]-dP[ri]) + Math.abs(dA[ri+1]-dP[ri+1]) + Math.abs(dA[ri+2]-dP[ri+2]);
                            
                            if (diff > thresh) {
                                dOut[i]=dA[ri]; dOut[i+1]=dA[ri+1]; dOut[i+2]=dA[ri+2];
                            } else {
                                if (crush > 0 && Math.random()*100 < 5) {
                                    const n = (Math.random()-0.5)*crush;
                                    dOut[i]=dC[i]+n; dOut[i+1]=dC[i+1]+n; dOut[i+2]=dC[i+2]+n;
                                } else {
                                    dOut[i]=dC[i]; dOut[i+1]=dC[i+1]; dOut[i+2]=dC[i+2];
                                }
                            }
                            dOut[i+3]=255;
                        }
                    }
                }
                else if (layer.type === 'quantize') {
                    // NEW MODE: Quantize (Motion Quantization / Aliasing)
                    // Logic: Process frames in larger blocks.
                    const blockSize = Math.max(1, p[0]); // Size of quantization block
                    const thresh = p[1] * 1.5;
                    const crush = p[2];

                    for (let y = 0; y < h; y += blockSize) {
                        for (let x = 0; x < w; x += blockSize) {
                            // Calc average motion or just use top-left of block
                            const i = (y*w+x)*4;
                            const diff = Math.abs(dA[i]-dP[i]) + Math.abs(dA[i+1]-dP[i+1]) + Math.abs(dA[i+2]-dP[i+2]);
                            
                            let updateBlock = diff > thresh;
                            
                            // Fill block
                            for (let by = 0; by < blockSize; by++) {
                                for (let bx = 0; bx < blockSize; bx++) {
                                    if (y+by >= h || x+bx >= w) continue;
                                    
                                    const bi = ((y+by)*w + (x+bx))*4;
                                    if (updateBlock) {
                                        dOut[bi]=dA[bi]; dOut[bi+1]=dA[bi+1]; dOut[bi+2]=dA[bi+2]; dOut[bi+3]=255;
                                    } else {
                                        // Use previous buffer value (Stick)
                                        if (crush > 0 && Math.random()*100 < 2) {
                                            const n = (Math.random()-0.5)*crush;
                                            dOut[bi]=dC[bi]+n; dOut[bi+1]=dC[bi+1]+n; dOut[bi+2]=dC[bi+2]+n;
                                        } else {
                                            dOut[bi]=dC[bi]; dOut[bi+1]=dC[bi+1]; dOut[bi+2]=dC[bi+2];
                                        }
                                        dOut[bi+3]=255;
                                    }
                                }
                            }
                        }
                    }
                }
                else if (layer.type === 'drift') {
                    // NEW MODE: Drift (Vector Drift)
                    // Logic: Constant offset applied to buffer + standard refresh
                    const sx = Math.floor((p[0]-50) * 0.5); // Speed X
                    const sy = Math.floor((p[1]-50) * 0.5); // Speed Y
                    const noise = p[2];

                    for (let y = 0; y < h; y++) {
                        for (let x = 0; x < w; x++) {
                            const i = (y*w+x)*4;
                            // Check video motion first (to refresh pixels)
                            const diff = Math.abs(dA[i]-dP[i]) + Math.abs(dA[i+1]-dP[i+1]) + Math.abs(dA[i+2]-dP[i+2]);
                            
                            if (diff > 40) { // Hardcoded refresh thresh for drift stability
                                dOut[i] = dA[i]; dOut[i+1] = dA[i+1]; dOut[i+2] = dA[i+2];
                            } else {
                                // Drift: Read buffer from offset coords
                                let ox = x - sx;
                                let oy = y - sy;
                                
                                // Wrap coords? or Clamp? Clamp looks smearier.
                                ox = Math.min(Math.max(ox, 0), w-1);
                                oy = Math.min(Math.max(oy, 0), h-1);
                                
                                const oi = (oy*w+ox)*4;
                                
                                dOut[i] = dC[oi]; dOut[i+1] = dC[oi+1]; dOut[i+2] = dC[oi+2];
                                
                                if (noise > 0 && Math.random()*100 < 1) {
                                     dOut[i]+=noise; dOut[i+1]+=noise; dOut[i+2]+=noise;
                                }
                            }
                            dOut[i+3] = 255;
                        }
                    }
                }
                else if (layer.type === 'freeze') {
                    // NEW MODE: Freeze (Vector Freeze Zones)
                    const radius = (p[0] / 100) * (h/2);
                    const feather = p[1];
                    const invert = p[2] > 50;
                    const cx = w/2;
                    const cy = h/2;

                    for (let y = 0; y < h; y++) {
                        for (let x = 0; x < w; x++) {
                            const i = (y*w+x)*4;
                            const dist = Math.sqrt((x-cx)*(x-cx) + (y-cy)*(y-cy));
                            
                            let isFrozen = dist < radius;
                            if (invert) isFrozen = !isFrozen;

                            if (isFrozen) {
                                // Force Freeze: Keep buffer
                                dOut[i] = dC[i]; dOut[i+1] = dC[i+1]; dOut[i+2] = dC[i+2];
                            } else {
                                // Normal update (Pass through A)
                                // Or should it be Smear? Let's make it standard video pass-through for contrast.
                                dOut[i] = dA[i]; dOut[i+1] = dA[i+1]; dOut[i+2] = dA[i+2];
                            }
                            dOut[i+3] = 255;
                        }
                    }
                }
                else if (layer.type === 'echo') {
                    // NEW MODE: Echo (Vector Echo)
                    const decay = p[0] / 100; // Blend amount
                    const offset = Math.floor(p[1] / 5); // Shift
                    const thresh = p[2] * 2; // Motion thresh to generate echo

                    for (let y = 0; y < h; y++) {
                        for (let x = 0; x < w; x++) {
                            const i = (y*w+x)*4;
                            
                            // Blend current video A with Buffer
                            // dOut = VideoA * (1-decay) + Buffer * decay
                            
                            let r, g, b;
                            
                            // Simple Echo
                            r = dA[i] * (1-decay) + dC[i] * decay;
                            g = dA[i+1] * (1-decay) + dC[i+1] * decay;
                            b = dA[i+2] * (1-decay) + dC[i+2] * decay;
                            
                            dOut[i] = r; dOut[i+1] = g; dOut[i+2] = b; dOut[i+3] = 255;
                        }
                    }
                }
                else if (layer.type === 'transfer') {
                    const sensitivity = (100 - p[0]) * 3;
                    const isRev = p[3] === 1; // Direction Switch
                    
                    const srcDriver = isRev ? (frameB ? frameB.data : dA) : dA; // If B->A, driver is B (if exists)
                    const srcPaint  = isRev ? dA : (frameB ? frameB.data : dA); // If B->A, paint is A
                    
                    const paintSource = isRev ? dA : (frameB ? frameB.data : dA); 

                    for (let i=0; i<dA.length; i+=4) {
                        const diff = Math.abs(dA[i]-dP[i]) + Math.abs(dA[i+1]-dP[i+1]) + Math.abs(dA[i+2]-dP[i+2]);
                        
                        if (diff > sensitivity) {
                            dOut[i]=paintSource[i]; dOut[i+1]=paintSource[i+1]; dOut[i+2]=paintSource[i+2];
                        } else {
                            dOut[i]=dC[i]; dOut[i+1]=dC[i+1]; dOut[i+2]=dC[i+2];
                        }
                        dOut[i+3]=255;
                    }
                }
                else if (layer.type === 'rgb') {
                    const rx=p.rx, ry=p.ry, gx=p.gx, gy=p.gy, bx=p.bx, by=p.by;
                    for (let y=0; y<h; y++) {
                        for (let x=0; x<w; x++) {
                            const i = (y*w+x)*4;
                            const getIdx = (xx, yy) => {
                                xx = Math.min(Math.max(xx,0), w-1);
                                yy = Math.min(Math.max(yy,0), h-1);
                                return (yy*w+xx)*4;
                            };
                            dOut[i]   = dC[getIdx(x+rx, y+ry)];     // R
                            dOut[i+1] = dC[getIdx(x+gx, y+gy)+1];   // G
                            dOut[i+2] = dC[getIdx(x+bx, y+by)+2];   // B
                            dOut[i+3] = 255;
                        }
                    }
                }
                else if (layer.type === 'slice') {
                     const chance=p[0], height=Math.max(1, p[1]), amp=p[2]*2;
                     let shift=0, rem=0;
                     for (let y=0; y<h; y++) {
                        if(rem<=0) {
                            if(Math.random()*100 < chance) { rem=Math.random()*height; shift=(Math.random()-0.5)*amp; }
                            else shift=0;
                        } else rem--;
                        for (let x=0; x<w; x++) {
                            let sx = x+shift;
                            if(sx<0) sx+=w; if(sx>=w) sx-=w;
                            sx = Math.min(Math.max(Math.floor(sx),0), w-1);
                            const i=(y*w+x)*4; const si=(y*w+sx)*4;
                            dOut[i]=dC[si]; dOut[i+1]=dC[si+1]; dOut[i+2]=dC[si+2]; dOut[i+3]=255;
                        }
                     }
                }
                else if (layer.type === 'noise') {
                    const grain=p[0], interf=p[1], roll=Math.floor(Math.random()*p[2]);
                    for (let y=0; y<h; y++) {
                        let sy = (y+roll)%h;
                        let isLine = Math.random()*100 < interf;
                        for (let x=0; x<w; x++) {
                            const i=(y*w+x)*4; const si=(sy*w+x)*4;
                            if(isLine) { dOut[i]=Math.random()*255; dOut[i+1]=Math.random()*255; dOut[i+2]=Math.random()*255; }
                            else {
                                const n = (Math.random()-0.5)*grain;
                                dOut[i]=dC[si]+n; dOut[i+1]=dC[si+1]+n; dOut[i+2]=dC[si+2]+n;
                            }
                            dOut[i+3]=255;
                        }
                    }
                }
                else if (layer.type === 'difference') {
                    const thresh=p[0], hue=p[2]*2;
                    for (let i=0; i<dA.length; i+=4) {
                        const diff = Math.abs(dA[i]-dP[i]) + Math.abs(dA[i+1]-dP[i+1]) + Math.abs(dA[i+2]-dP[i+2]);
                        if (diff > thresh) {
                            dOut[i]=dA[i]; dOut[i+1]=dA[i+1]; dOut[i+2]=dA[i+2];
                        } else {
                            if(hue<50) { dOut[i]=dC[i]-1; dOut[i+1]=dC[i+1]-5; dOut[i+2]=dC[i+2]-1; }
                            else { dOut[i]=dC[i+1]-1; dOut[i+1]=dC[i+2]-5; dOut[i+2]=dC[i]-1; }
                        }
                        dOut[i+3]=255;
                    }
                }
                else if (layer.type === 'luma_wipe') {
                    const thresh=p[0]*2.55, soft=p[1];
                    const dir=p[3] === 1; // 0: A->B, 1: B->A
                    const src1 = dA;
                    const src2 = frameB ? frameB.data : dA;
                    
                    // In Luma Wipe:
                    // A->B: A is base, B is revealed by luma.
                    // B->A: B is base, A is revealed.
                    
                    const base = dir ? src2 : src1;
                    const reveal = dir ? src1 : src2;
                    
                    // We use A's luma map for consistency? Or Base's luma map?
                    // Let's use Base's luma map to wipe itself away.
                    
                    for (let i=0; i<dA.length; i+=4) {
                        const luma = (base[i]+base[i+1]+base[i+2])/3;
                        let showReveal = luma < thresh; // Reveal if dark? Or Light?
                        // Let's say Threshold is "Progress".
                        
                        if(showReveal) { 
                            dOut[i]=reveal[i]; dOut[i+1]=reveal[i+1]; dOut[i+2]=reveal[i+2]; 
                        } else { 
                            dOut[i]=dC[i]; dOut[i+1]=dC[i+1]; dOut[i+2]=dC[i+2]; 
                        }
                        dOut[i+3]=255;
                    }
                }
                 else if (layer.type === 'interlace') {
                    const height=Math.max(1, Math.floor(p[0]/2)), scan=p[1], jitter=Math.random()*p[2];
                    const isRev = p[3] === 1;
                    const src1 = dA;
                    const src2 = frameB ? frameB.data : dA;
                    
                    const evenSrc = isRev ? src2 : src1;
                    const oddSrc  = isRev ? src1 : src2;
                    
                    for (let y=0; y<h; y++) {
                        const isEven = (Math.floor((y+jitter)/height)%2 === 0);
                        const source = isEven ? evenSrc : oddSrc;
                        
                        for (let x=0; x<w; x++) {
                            const i=(y*w+x)*4;
                            dOut[i]=source[i]; dOut[i+1]=source[i+1]; dOut[i+2]=source[i+2];
                            dOut[i+3]=255;
                        }
                    }
                }
                else if (layer.type === 'sort') {
                    const drift=Math.floor(p[0]/5), thresh=p[1]*2.55, isVert=p[2]<50;
                    for (let y=0; y<h; y++) {
                        for (let x=0; x<w; x++) {
                            const i=(y*w+x)*4;
                            const bright = (dA[i]+dA[i+1]+dA[i+2])/3;
                            if(bright>thresh) {
                                let offI;
                                if(isVert) { const offY=Math.max(0,y-drift); offI=(offY*w+x)*4; }
                                else { const offX=Math.max(0,x-drift); offI=(y*w+offX)*4; }
                                dOut[i]=dC[offI]; dOut[i+1]=dC[offI+1]; dOut[i+2]=dC[offI+2];
                            } else {
                                dOut[i]=dA[i]; dOut[i+1]=dA[i+1]; dOut[i+2]=dA[i+2];
                            }
                            dOut[i+3]=255;
                        }
                    }
                }
                buffer = outputData;
            });

            currentCanvas.data.set(buffer);
            ctx.putImageData(currentCanvas, 0, 0);
            previousFrameData = frameA;
        }

        // --- Rec/Snap ---
        recordBtn.onclick = () => {
            if(isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                recordBtn.classList.remove('bg-red-600', 'text-white');
                recordBtn.classList.add('bg-red-900/20', 'text-red-500');
                recDot.classList.remove('animate-ping', 'bg-white');
                recText.textContent = "REC OUTPUT";
            } else {
                const stream = canvas.captureStream(30);
                mediaRecorder = new MediaRecorder(stream, {mimeType: 'video/webm'});
                recordedChunks = [];
                mediaRecorder.ondataavailable = e => { if(e.data.size>0) recordedChunks.push(e.data); };
                mediaRecorder.onstop = () => {
                    const blob = new Blob(recordedChunks, {type:'video/webm'});
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url; a.download = `datamosh_${Date.now()}.webm`;
                    a.click();
                    recordBtn.innerHTML = "SAVED!";
                    setTimeout(() => recordBtn.innerHTML=`<div id="recDot" class="w-3 h-3 rounded-full bg-red-600"></div><span id="recText">REC OUTPUT</span>`, 2000);
                };
                mediaRecorder.start();
                isRecording = true;
                recordBtn.classList.add('bg-red-600', 'text-white');
                recDot.classList.add('animate-ping', 'bg-white');
                recText.textContent = "STOP REC";
            }
        };
        snapBtn.onclick = () => {
            const a = document.createElement('a');
            a.download = 'datamosh_snap.png'; a.href = canvas.toDataURL(); a.click();
        };
        document.getElementById('helpBtn').onclick = () => guideOverlay.classList.remove('hidden');
        
        initCanvas();
    </script>
</body>
</html>
